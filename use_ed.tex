\title{Why every hacker should try \lstinline{ed}}
\author{
        James Baldwin-Brown \\
}
\date{\today}

\documentclass[12pt]{article}
\usepackage{tabu}
\usepackage{listings}

\begin{document}
\maketitle

\begin{abstract}
\end{abstract}

\section{Introduction}

Much has been written about the value of the \lstinline{ed} text editor
and its importance to the history of programming culture, especially
in Unix hacker circles. The short version is that, in the late 1960s,
Ken Thompson wrote a simplified version of the \lstinline{qed} editor
to use with the nascent Unix operating system and, until Bill Joy
wrote \lstinline{vi} in 1976, it was the only widely available Unix
text editor.

\lstinline{ed} wasn't merely the only editor around, however --
it included a set of powerful features, and one in particular,
that made it one of the most useful text editors available at
that time. The extreme power and flexibility of this simple
program were instrumental in the development of the Unix philosophy,
with its emphasis on scriptability, doing one thing well, handling
text with regular expressions, and inventing little languages
to solve specific tasks. It all began with \lstinline{ed}.

\lstinline{ed} was, at least nominally, the standard Unix text editor
for several decades.
There is a recurring joke on the internet, going back to at least the early
USENET days,
that \lstinline{ed}'s place as the standard editor was a comical throwback
to a time when RAM (or \emph{core} for the elder statesmen) was measured
in kilobytes, having been superseded in terms of usability by much more
powerful editors such as \lstinline{vi} and \lstinline{emacs}.
I am not interested in arguing that \lstinline{ed} is better
than newer editors, but instead argue here that many of the
best qualities of the Unix philosophy are reflected by the design decisions
in its original text editor.
Whatever \lstinline{ed}'s faults may be, it was the text editor used to write
the Unix kernel, shell, and userspace tools. Since the creators of Unix
wrote their own text editor, they could have written a better one. It is
of note that most of the Bell labs alumni that created Unix continued
to use \lstinline{ed} long after \lstinline{vi} and other full-screen editors
became available, and eventually wrote their own replacements for \lstinline{ed},
\lstinline{sam} and \lstinline{acme}, that hew much closer to \lstinline{ed}'s
original regex-oriented user interface.

\section{Minimalism}

The original \lstinline{ed} source code is only [] lines of code.
Not bad for an editor that includes a full regular expression engine
and complete scriptability. This was due partially to the technical constraints
of the time (the PDP-7 on which \lstinline{ed} ran had only [] of core memory),
but had more to do with a philosophy that one should use just enough code,
and no more, to complete the task at hand. This turned out to be one of the
strengths of Unix generally -- a na√Øve hacker could read and digest the entire
codebase because all code was as small and simple as it could be made. This allowed
new programmers to quickly get up to speed and begin modifying the source, even
if they didn't know the original authors.
\section{Regular expressions}

Apart from straightforward entry of text, the primary method
for editing text in \lstinline{ed} is regular expression
find-and-replace. In fact, because \lstinline{ed} is a line editor,
this is the only way to edit text without rewriting an entire line
at the minimum. First time users of \lstinline{ed} find this
constraining, but the extreme flexibility of regular expressions
allows for arbitrarily complex edits on any text. With practice,
this becomes as natural, and quick, as any other type of interactive
editing. This type of edit is also naturally extensible to multi-line
editing, a feature that is often touted as a killer ``new'' feature of
modern text editors (see sublime text, atom, or Visual Studio Code).
\lstinline{ed} is the program that introduced the convention,
in Unix programs, that regular expressions should be surrounded
by /slashes/ and should be prefixed by commands (`s', `g') and suffixed
by options (`p', `2', `l').

\section{Scriptability}

\lstinline{ed} was intended to be used interactively. A typical \lstinline{ed}
session looks something like this:

\begin{lstlisting}
$ ls
ed_print.c
$ ed ed_print.c
93
,p
#include <stdio.h>

int main() {
    printf("ed is the standard editor\n");
    return(0);
}
/printf
    printf("ed is the standard editor\n");
s/the.*ard/a good/p
    printf("ed is a good editor\n");
w
87
q
\end{lstlisting}

Here, the author opens the file ``ed\_print.c'' using ed,
prints the contents of the file (\lstinline{1,$p} indicates
that one should ``p''rint the lines from 1 until the end of the document),
searches (/) for a \lstinline{printf} line,
then ``s''ubstitutes the phrase ``a good'' for the regular
expression \lstinline{the.*ard}.
This is accomplished entirely in a unixy way -- \lstinline{ed} opens
up a file, then applies operations to the file using commands
sent to it over \lstinline{stdin}. Because it accepts commands
directly on \lstinline{stdin}, \lstinline{ed} can be used just
as easily to run pre-cooked `scripts' of \lstinline{ed} commands
as it can be used interactively. It is this killer feature that
led to its greatest influence on Unix: the creation of pipeable
shell tools and little languages.

\section{Descendants of \lstinline{ed}}



% \lstinline{ed} is still as usable today as
% it was in 1969, and using \lstinline{ed} for a few days or weeks will let

% \begin{table}
%     \begin{center}
%         \begin{tabu}to 0.8\linewidth {XXX}
%             Card Name & Numerical value & Alphabetic mapping\\
%             \hline\\
%             King & 0 & D\\
%             Ace & 1 & A\\
%             Deuce & 2 & K\\
%             3 & 3 & H\\
%             4 & 4 & E\\
%             5 & 5 & B\\
%             6 & 6 & L\\
%             7 & 7 & I\\
%             8 & 8 & F\\
%             9 & 9 & C\\
%             10 & 10 & M\\
%             Jack & 11 & J\\
%             Queen & 12 & G\\
%         \end{tabu}
%         \caption{Mapping to a new address space.}
%         \label{table:map}
%     \end{center}
% \end{table}

\end{document}
